\chapter{Automated generation of safety constraints}
\label{chap:automatedgenerationofsafetyconstraints}

Safety constraints primarily constitute essential properties which describe correct and safe behaviour of safety critical software applications. In order to discover whether a program meets its safety requirements, its behaviour is checked by the constraints. This happens mostly as a last check before software gets released. 
But regarding updating and maintenace work, often further changes are made to the software even after release.
%But even after possible changes to the software in the context of updating and maintenance work,
However, safety constraints can be applied again and assure the adherence of all properties. Safety constraints thus are also suitable for sustaining consistency during the different phases of software life. In fact, not only safety constraints, also properties of program behaviour which are not safety relevant at all are applicable for that. The more constraints are defined the the better can be the reliability.
But as already mentioned before, it might be difficult for developers to find all reasonable %safety
constraints by hand. % which are needed for full safety covery.
In this case it can happen that a prior correct software version becomes faulty over time because of minor adjustments once in a while which are not covered by constraints.
%To help prevent this to happen

As a solution to this problem, the concept of automated constraint generation for state machines is proposed. Once the initial implementation of a program is finished, its behaviour can be analysed. Sgnificant parts of it can be determined automatically and put into constraint representation which are valid on the current program of course.
%constraint suggestions which are valid on the current program can be computed fully automatically. 
On the one hand, the constraint suggestions may help the developer identifying reasonable constraints he did not think about as well as contradictions between program and specification, eg. if a computed constraint does not make sense at all.
On the other hand, all constraints can be revalidated after each change to the software and thus ensure consistency.

In order to support the developer in developing safe programs and to simplify maintainability, automated generation and suggestion of constraints might be helpful. But it's helpful only if the suggested constraints are relevant and reasonable.


\section{Subgraph definition}
\label{sec:subgraphdefinition}

Whether suggested constraints are relevant and reasonable
%This however
depends on the domain and use case. It has to be mentioned that the approach of finding an algorithm for constraint generation presented in this work has a special focus on the healtcare use cases and may not be applicable for other domains.
Regarding the important safety constraints postulated in chapter~\ref{chap:goals}, all the relevant states seem to fall into one of the following categories:

\begin{enumerate}
	\item States having two or more outgoing transitions ($\alpha$-states).
	\item States in which all paths starting from one $\alpha$-state come together again ($\beta$-states).
	\item All States immediately before $\beta$ states ($\gamma$-states).
\end{enumerate}

%All associated states which match these properties can be combined to a 
In order to compute the required constraints automatically, and possibly additional ones, for each $\alpha$-state all associated $\beta$-states and the one $\gamma$-state have to be determined. Such a group of states is named subgrap from now on. It is defined as follows:
%Each $\alpha$-, the corresponding $\beta$- and several $\gamma$-states form a part of a state set called \emph{subgraph}. In order to retreive valid constraints a subgraph is defined by the following requirements: %as follows

\begin{itemize}
	\item There is a start state ($\alpha$-state) with at least two outgoing transitions.
	\item There is one end state ($\beta$-state) in which all possible paths starting from start state come together again.
	\item All states between the start and end states have no other incoming transitions than the ones originally coming from the start state. That means there is no path to visit these states except through the start state.
	\item The start state may have incoming transitions from states not contained in the subgraph.
	\item The end state may have incoming and outgoing transitions from and to states not contained in the subgraph.
\end{itemize}

A graphical example of such a subgraph is shown in Fig.~\ref{fig:subgraph}. Using this specification all possible subgraphs of this kind can be detected within a state machine. An algorithm how subgraphs can be computed programmatically is discussed later in section~\ref{sec:prototype:automatedconstraintgeneration}.

\begin{figure}[htbp]
  \centering
  
  \tikzstyle{state} = [circle,fill=white,draw]
  \tikzstyle{statein} = [circle,fill=blue!20,draw]
  \tikzstyle{every path} = [font=\sffamily\small]
  
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=15mm]
	
	
%	  \node[statein] (1) {$\alpha$};
%	  \node[state] (2) [above left of=1] {};
%	  \node[state] (3) [below left of=1] {};
%	  \node[statein] (4) [above right of=1] {};
%	  \node[statein] (5) [below right of=1] {};
%	  \node[statein] (8) [right of=5] {$\gamma$};
%	  \node[statein] (6) [right of=4] {$\gamma$};
%	  \node[statein] (7) [below right of=4] {$\gamma$};
%	  
%	  \node[statein] (9) [right of=7] {$\beta$};
%	  \node[state] (10) [above of=9] {};
%	  \node[state] (11) [above right of=9] {};
%	  \node[state] (12) [below right of=9] {};
%	  
%	  \path[dashed]
%	    (2) edge node [left] {} (1)
%	    (3) edge node [left] {} (1)
%	    (10) edge node [left] {} (9)
%	    (9) edge node [left] {} (11)
%	    (9) edge node [left] {} (12);
%		\path[]
%	  	(1) edge node [left] {} (4)
%	        edge node [left] {} (5)
%	    (4) edge node [left] {} (6)
%	        edge node [left] {} (7)
%	    (5) edge node [left] {} (8)
%	    (6) edge node [left] {} (9)
%	    (7) edge node [left] {} (9)
%	    (8) edge node [left] {} (9)
%	    ;
	    
	    
	  \node[statein] (1) {$\alpha$};
	  \node[state] (2) [above left of=1] {};
	  \node[state] (3) [above right of=1] {};
	  \node[statein] (4) [below left of=1] {};
	  \node[statein] (6) [below of=4] {$\gamma$};
	  \node[statein] (7) [below right of=4] {$\gamma$};
	  \node[statein] (5) [below right of=1] {};
	  \node[statein] (8) [below of=5] {$\gamma$};
	  \node[statein] (9) [below of=7] {$\beta$};
	  \node[state] (10) [right of=9] {};
	  \node[state] (11) [below left of=9] {};
	  \node[state] (12) [below right of=9] {};
	  
	  \path[dashed]
	    (2) edge node [left] {} (1)
	    (3) edge node [left] {} (1)
	    (10) edge node [left] {} (9)
	    (9) edge node [left] {} (11)
	    (9) edge node [left] {} (12);
		\path[]
	  	(1) edge node [left] {} (4)
	        edge node [left] {} (5)
	    (4) edge node [left] {} (6)
	        edge node [left] {} (7)
	    (5) edge node [left] {} (8)
	    (6) edge node [left] {} (9)
	    (7) edge node [left] {} (9)
	    (8) edge node [left] {} (9)
	    ;
	
	\end{tikzpicture}
  \caption{Example for a subgraph.}
  \label{fig:subgraph}
\end{figure}




\section{Constraint determination}

For the healthcare applications, all important states which concern safety constraints belong to subgraphs. Thus, several safety properties can be formulated based on the structure of subgraphs.
For each subgraph the following valid LTL formulas can be derived if it contains neither inner (infinite) loops nor final states (states having no outgoing transition). In the following $\alpha$ is proposition for ``$\alpha$ is current state'' and similarly $\beta$ and $\gamma$:

\begin{equation} \label{eq:first}
  \models \Box (\alpha \rightarrow \Diamond \beta)
\end{equation}

\begin{equation} \label{eq:second}
  \models \Box (\alpha \rightarrow \Diamond (\bigvee_{\gamma} \gamma))
\end{equation}

\begin{equation} \label{eq:third}
  \models \Box (\alpha \rightarrow [\neg \beta \mathcal{U} \bigvee_{\gamma} \gamma])
\end{equation}

Additionally, for all states not contained in the subgraph (let's call them $\delta$-states, and the proposition $\delta$ stands for ``$\delta$ is current state'') the following formula is true: 

\begin{equation} \label{eq:fourth}
  \models \Box (\alpha \rightarrow [(\bigwedge_{\delta} \neg \delta) \mathcal{U} \beta])
\end{equation}

In case of $\alpha = \beta$ - i.e. when all paths starting from $\alpha$-state eventually return again (cycle) - even another constraint can be assumed to be true:

\begin{equation} \label{eq:fifth}
  \models \Box \Diamond \alpha
\end{equation}
 

These five constraints apply to each subgraph matching the conditions mentioned above. Formula~\ref{eq:first} says that an $\alpha$-state is always eventually followed by a $\beta$-state. Formula~\ref{eq:second} ensures that there will always at least one $\gamma$-state be eventually visited after each visit of an $\alpha$-state. The quite similar but stricter formula~\ref{eq:third} additionally demands a visit of at least one $\gamma$-state before the $\beta$-state can be reached. Formula~\ref{eq:fourth} simply says that a state not contained in the subgraph can't be visited between $\alpha$- and $\beta$-states. The constraint that the $\alpha$-state will always eventually be visited again is expressed by formula~\ref{eq:fifth}.

All formulas can be translated to the visual formalism presented in section~\ref{sec:operatorconstraintformalism} and shown to the user. The appropriate LTL formulas for the constraints postulated in chapter~\ref{chap:goals} relate to number \ref{eq:second} and \ref{eq:fifth} of the subgraph based formula templates and are as follows:

\begin{equation} \label{eq:sixth}
  \models \Box \Diamond \textnormal{'Polling'}
\end{equation}

\begin{equation} \label{eq:seventh}
	\models \Box (\textnormal{'Not taken yet'} \rightarrow \Diamond (\textnormal{'Well done!'} \vee \textnormal{'Staff notified'})
\end{equation}
%	\item The program will always eventually check the database for new reminder jobs. Thus we avoid that pending reminder are never processed.
%	\item Either a reminded medication is taken properly or caregivers get notified whenever a patient refuses medication intake.

Formula~\ref{eq:sixth} ensures that state ``Polling'' will always eventually be visited again, and formula~\ref{eq:seventh} specifies that either state ``Well done!'' or state ``Staff notified'' will be eventuelly visited after each visit of ``Not taken yet''.