\chapter{Conclusion \& future work}
\label{chap:conclusionandfuturework}

first step towards safety certification

In this paper we presented a visual formalism for the defining of safety constraints and first steps towards a concept of automatic constraint generation. Both features are implemented and assembled in an editor for standalone or integrated use. The visual language is reasonably simple which makes it accessible to a wider range of software developers. Nevertheless it is reasonably expressive and allows serious model checking.

The concept of applying hueristics for proposing possible constraints to users of the visual language produced very good results in our use case, the medication reminder application. All postulated constraints were found and we even discovered a new reasonable constraint. Thus we are convinced that this approach, as well as the visual language for defining constraints itself, has the potential to really support users in development of safety critical robot applications in the healthcare domain and also other domains.

Perhaps the most important next step we identified is the application of the language and the constraint generation heuristic to other domains and applications. This will reveal if the identified subgraph-based heuristic for constraint generation provides reasonable results also in different scenarios. Most likely, it will be necessary to identify further heuristics and integrate them in the visual language editor to improve user support. A study among a group of users from the healthcare robotics domain could indicate the potential of usability improvements.

Some improvements on the feature side of the language or the editor were already identified. For example, the state proposition (currently the only supported proposition type) used in constraint formulation might be not enough for other domains. Supporting propositions based on strings or mumerical equations might be necessary. Finally, the only result of constraint checking presented to the user currently is whether the constraint is valid or invalid. In contrast to conventional model checking no additional explanation for the outcome such as a counter example is given. It can be considered to extend the visual language with support for bug identification by a visualization of counter examples, for example.
%\item Substitution of parts of constraints would be nice in order to make it easier to understand. (A simple operator which abstracts from a more complex operator). It's comparable to composite states of hirachical state machines.

%\item A feature which can display an counter example in case a constraint is not valid. It would make the user comprehend the reason in what situation a constraint fails.

%	\item constraints bewerten (nach gewichtung?) und nur wichtige vorschlagen? Oder zumindest sortieren


%\begin{itemize}
%	\item Yet, there are only states and no variable expressions etc.
%	\item Substitution of parts of constraints would be nice in order to make it easier to understand. (A simple operator which abstracts from a more complex operator). It's comparable to composite states of hirachical state machines.
%	\item A feature which can display an counter example in case a constraint is not valid. It would make the user comprehend the reason in what situation a constraint fails.
%	\item Problem mit der Zustandsbenennung! Die Zustände müssen passende Namen haben, was aber nicht immer möglich ist. Daher müsste man eigentlich auch Transitionsbedingungen in den Constraints erlauben
%	\item constraints bewerten (nach gewichtung?) und nur wichtige vorschlagen? Oder zumindest sortieren
%	\item übertragbarkeit auf andere domänen untersuchen?
%	\item A bigger generation algorithm. As already metioned our approach only targets the healthcare domain. Especially the constraint generation can be improved to match also other domains.
%\end{itemize}

%1. Save and load functionality of constraints
%2. Yet, there are only states and no variable expressions etc.
%3. Substitution of parts of constraints would be nice in order to make it easier to understand. (A simple operator which abstracts from a more complex operator). It's comparable to composite states of hirachical state machines.
%4. A feature which can display an counter example in case a constraint is not valid. It would make the user comprehend the reason in what situation a constraint fails.
%5. A bigger generation algorithm
%6. constraints bewerten und nur wichtige vorschlagen? Oder zumindest sortieren
%7. uebertragbarkeit auf andere domaenen untersuchen?