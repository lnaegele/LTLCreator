\chapter{Test scenario and evaluation}
\label{chap:testscenarioandevaluation}

In order to evaluate the proposed safety functionality we use the Robostudio version where we already integrated LTLCreator in. This visual programming environment allows the specification of state machine based programs whose behaviour can then be examined by visual constraints.
As a test scenario we consider the simplified medication reminder application whose underlying screen-flow is explained in figure~\ref{fig:medicationreminder}. Starting from ``Menu'' the user can choose from several services such as blood pressure measurement or entertainment. In the given example these services are simplified to just one state ``additional services'' since we want to focus only on the medication reminder part. In ``Polling'' the database is checked for a pending reminder, and if there is one the medication intake guidance is triggered. The patient can state if he or she has already taken the medication, or decide whether to take it or not. In the latter he or she may give a reason for it and a caregiver is notified about this incident. Otherwise it will result in ``Well done!'' after completing intake.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\linewidth]{stm.pdf}
  \caption{Simplified screen-flow of the medication reminder application.}
  \label{fig:medicationreminder}
\end{figure}

This state machine with all its states, transitions and screen dialogs has been implemented in Robostudio and in the following sections we will evaluate the visual language as well as the capability of constraint generation. In section~\ref{sec:reliability} a short statement about reliability of the features is given.



\section{Operator constraints}

Before we can start creating constraints it might be useful to think about a reasonable term we want to express. Let's take the example ``Whenever there is a pending reminder, medication will be finally taken or caregivers will get notified in case of the patient refusing medication intake.'' given as a requirement in chapter~\ref{chap:goals}.

In order to find a corresponding graphical constraint the sentence has to be analyzed just as you read it. Since ``whenever'' is a semantic equivalent to ``always if'' first of all a \emph{ALWAYS} operator gets dragged to the dashboard directly followed by an \emph{IF} as shown in figure~\ref{fig:sampleconstraint}. The condition for this \emph{IF} is that there is a pending reminder, so a state ``Not taken yet'' has to be added to the upper bucket of the \emph{IF} operator.
Whenever the just mentioned condition becomes true, there also has to be true in future: Medication is taken properly or caregivers get notified about refuse. Accordingly a \emph{FUTURE} operator containing an \emph{OR} forms the second part of the \emph{IF} operator. Finally two states 'Well done!' and 'Staff notified' get added to the disjunction. The resulting visual constraint can now automatically be translated to the corresponding LTL formula by the editor:

\begin{equation} \label{eq:sampleconstraint}
  \models \Box (\textnormal{'Not taken yet'} \Rightarrow \Diamond (\textnormal{'Well done!'} \vee \textnormal{'Staff notified'}))
\end{equation}

%This expression can now be translated to the visual form as we just have to break down the formula from the outside to the inside. A surrounding \emph{GLOBALLY} encapsulates an \emph{IF} block since it is the substitution for \emph{IMPLIES}. Its first operator is a proposition \emph{'Not taken yet'} whereas the second parameter has to be a \emph{FOLLOWS} block containing a disjunction of two propositions \emph{'Well done!'} and \emph{'Staff notified'}. The resulting visual constraint is shown in figure~\ref{fig:sampleconstraint}.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.65]{sampleconstraint}
  \caption{Visual constraint creation for LTL formula ~\ref{eq:sampleconstraint}.}
  \label{fig:sampleconstraint}
\end{figure}

After each change in the dashboard, the constraint is automatically recompiled and revalidated by using the underlying model checker. For syntactically invalid constraints, an ``incomplete'' sign is displayed in the respective tab. Otherwise, an animated ring indicates that validation is in pro\-gress and will finally result in either a ``valid'' or ``invalid'' sign.

Due to the optimized performance of NuSMV, even the validation of constraints on huge and complex programs is fast and allows rapid feedback. In addition, the validation itself runs in the background without locking the dashboard. Therefore we avoid waiting times and disruptions during constraint development, which would be likely with conventional model checking where constraint development and constraint validation are alternating processes. Thus we consider our tool an improvement for the user experience.

We observed the different color flavours of the visual operators to be a good support for fast reading and understanding of constraints. Also the two dimensional composition and the round shapes of the operators turned out to 
give the language a schematic but not too rectangular look. Besides it is considered eye-candy what is the best motivation for using this visual language.





\subsection{Expressiveness}

Ausdruckssärke gleich zu LTL, das heißt, dass lediglich Möglichkeiten nicht ausgedrückt werden können. Zudem gilt eine weitere Einschränkung, dass als bedingungen bisher nur Aussagen der Form ``ist in Zustand x'' verwendet werden können. Da die Validierung der healtbot anwendungen derzeit ausschließlich diesen typ braucht, sind andere Bedingungen wie Stringvergleich oder numerische Gleichheit bisher mit der visuellen Sprache nicht möglich. In Figure~\ref{fig:example_propositions} ist aufgezeigt, wie eine Erweiterung des LTLCreators um weitere Bedingungstypen aussehen könnte.


\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.65]{example_propositions}
  \caption{Possible proposition extensions: numeric and string equations.}
  \label{fig:example_propositions}
\end{figure}



\section{Automated constraint generation}

The automated constraint generation can be triggered by a click on the magic wand button in the tab area. After activation a dashboard is opened in a new tab for each found constraint, and validation is initiated immediately. For the medication reminder application six constraints are found, including \emph{a)} and \emph{b)} shown in figure~\ref{fig:generatedconstraints} which match the postulations in the requirements in chapter~\ref{chap:goals}.
The constraint used for demonstration in the previous section is also generated, however \emph{b)} forms an intensified restriction of it. 
Constraint \emph{a)} ensures the ``Polling'' state is always eventually visited again. If a pending medication is not already taken, constraint \emph{b)} guarantees intake or staff notification before the next reminders can be read from the database.

The search and generation process finishes within less than a second and thus doesn't make the developer wait a long time.

We showed that the subgraph approach is working for the medication reminder application, and there was even one more reasonable constraint found by the heuristic: Constraint \emph{c)} ensures that during the medication intake process the program can not switch back to the menu or other services such as entertainment or blood pressure measurement.



\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.65]{generatedconstraints}
  \caption{Automatically generated constraints which match the required postulations.}
  \label{fig:generatedconstraints}
\end{figure}






\subsection{Performance}

In order to examine the performance of sub graph finding and constraint generation, we need to have a second look at the implementation details again. The sub graph finding algorithm is realized as a depth-first search. Indeed all healthcare programs are infinite and contain cycles and a depth-first walk-through would never end, but the algorithm doesn't go deeper at already visited states.

The performance of this algorithm is of course highly dependend on the grade of branching. Nevertheless, such a depth-first search has an estimated wost case execution time of $O(|V|+|E|)$ in which $|V|$ is the number of states and $|E|$ number of edges respective transitions in our case.
Since we cope with state machines and thus have directed edges rather than undirected ones, each state can have $|E|=|V|$ transitions; $|V-1|$ to other ones and one to itself. As worst case ececution time for the depth-first search we obtain the following result:

\begin{equation}
O(\textnormal{``depth-first search''})=O(|V|)+O(|V|-1)=O(|V|)
\end{equation}

In order to find a sub graph with our presented algorithm the depth-first search has to be startet on a start state of a sub graph. Since we don't know in beforehand which states might be possible candidates for such start states, the algorithm has to be applied on every single state of the program which has two ore more outgoing transitions. In the worst case all $|V|$ states match this condition, so the depth-first search has to be executed $|V|$ times. This implies for our estimated worst case execution time:

\begin{equation}
O(\textnormal{``sub graph finding''})=O(|V|)*O(|V|)=O(|V|^2)
\end{equation}



\subsection{Scalability}

For all the healthcare applications the presented algorithm works brilliant and speedy. But their program sizes are still quite manageable.
Of course an exponential execution time is bad if the number of states arises. A clear slowdown can be felt when the algorithm runs on larger state machines with plenty of states and high grade of branching.

However, sholud this algorithm regardless its tailoring to the healthcare domain be used for other huge programs, it keeps a lot of potential to be improved in efficiency. With a sophisticated approach it might be enough to execute just one depth-first search for finding all sub graphs at once what would lead to a linear execution time.
% wenn noch schreiben will, dann: linear ist cool, weil das tool eh die gefundenen constraints gleich anzeigt und nicht erst am ende alles geballt bringt.


\subsection{Reasonability of generated constraints}

% hat uns die automatische generierung geholfen? Wuhu, wir haben noch einen constraint gefunden, der auch sinn macht
%practicality of constraints




\section{Reliability}
\label{sec:reliability}